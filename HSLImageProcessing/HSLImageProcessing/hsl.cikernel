/*vec4 rgb2hsl(vec4 color)
{
//Compute min and max component values
float MAX = max(color.r, max(color.g, color.b));
float MIN = min(color.r, min(color.g, color.b));

//Make sure MAX > MIN to avoid division by zero later
MAX = max(MIN + 1e-6, MAX);

//Compute luminosity
float l = (MIN + MAX) / 2.0;

//Compute saturation
float s = (l < 0.5 ? (MAX - MIN) / (MIN + MAX) : (MAX - MIN) / (2.0 - MAX - MIN));

//Compute hue
float h = (MAX == color.r ? (color.g - color.b) / (MAX - MIN) : (MAX == color.g ? 2.0 + (color.b - color.r) / (MAX - MIN) : 4.0 + (color.r - color.g) / (MAX - MIN)));
h /= 6.0;
h = (h < 0.0 ? 1.0 + h : h);

return vec4(h, s, l, color.a);
}*/

/*kernel vec4 _invertColor(sampler source_image) // 1
{
vec4 pixValue; // 2
pixValue = sample(source_image, samplerCoord(source_image)); // 3
unpremultiply(pixValue); // 4
pixValue.r = 1.0 - pixValue.r; // 5
pixValue.g = 1.0 - pixValue.g;
pixValue.b = 1.0 - pixValue.b;
return premultiply(pixValue); // 6
}*/

/*

vec4 hsv2rgb(vec4 color)
{float h = color.r;
float s = color.g;
float v = color.b;
h       = h*6.0;
float i = floor( h );
float f =  h -i ;
float p =  v * ( 1.0 - s );
float q =  v * ( 1.0 - s * f );
float t =  v * ( 1.0 - s * ( 1.0 - f ) );
float r = (i == 0.0 ?   v  :
(i == 1.0 ?   q  :
(i == 2.0 ?   p  :
(i == 3.0 ?   p  :
(i == 4.0 ?   t  :  v )))));
float g = (i == 0.0 ?   t  :
(i == 1.0 ?   v  :
(i == 2.0 ?   v  :
(i == 3.0 ?   q  :
(i == 4.0 ?   p  :  p )))));
float b = (i == 0.0 ?   p  :
(i == 1.0 ?   p  :
(i == 2.0 ?   t  :
(i == 3.0 ?   v  :
(i == 4.0 ?   v  :  q )))));
return vec4(r, g, b, color.a);
}*/

vec3 rgb2hsl(vec3 c){
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c){
/*vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);*/
vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing
return c.z * mix( vec3(1.0), rgb, c.y);
}

kernel vec4 hsl(sampler image, __color selectedColor, float saturation, float lightness)
{ vec4 pixel = sample(image, samplerCoord(image));
vec3 hslPixel = rgb2hsl(vec3(pixel.r,pixel.g,pixel.b));
vec3 hslColor = rgb2hsl(vec3(selectedColor.r,selectedColor.g,selectedColor.b));

float h = hslPixel.r;
float s = hslPixel.g;
float l = hslPixel.b;

if (h >= 0.8 && h<= 1.0) {
h += (hslColor.r - h);
s = saturation;
l = l + lightness > 1.0 ? 1.0 : l+lightness;
}



//

//s = saturation;//s+ saturation > 1.0 ? 1.0 : s+saturation;

vec4 newPixel = vec4(h, s, l, 1.0);
vec3 rgbPixel =  hsv2rgb(vec3(h,s,l));
return premultiply(vec4(rgbPixel.r,rgbPixel.g,rgbPixel.b,1.0));
}
/*
vec4 hsl2rgb(sampler image)
{ vec4 pixel = sample(image, samplerCoord(image));
return hsv2rgb(pixel);
}*/
