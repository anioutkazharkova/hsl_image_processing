
vec3 rgb2hsl(vec3 c){
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c){
vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing
return c.z * mix( vec3(1.0), rgb, c.y);
}

float leftColor(float hue, float dif){
if (hue - dif < 0) {
return 1.0 + (hue - dif);
} else {
return (hue - dif);
}
}

float rightColor(float hue, float dif){
if (hue + dif > 1) {
return (hue + dif) - 1.0;
} else {
return (hue + dif);
}
}


kernel vec4 hsl(sampler image, __color selectedColor, float colorShift, float sense, float saturation, float lightness)
{ vec4 pixel = sample(image, samplerCoord(image));
vec3 hslPixel = rgb2hsl(vec3(pixel.r,pixel.g,pixel.b));
vec3 hslColor = rgb2hsl(vec3(selectedColor.r,selectedColor.g,selectedColor.b));

float h = hslPixel.r;
float s = hslPixel.g;
float l = hslPixel.b;

float hslShift = colorShift;


if (h >= leftColor(0.3,sense) && h <= rightColor(0.3,sense)) {
h += (hslColor.r - h);

s = saturation;
l = l + lightness > 1.0 ? 1.0 : l+lightness;
}



//

//s = saturation;//s+ saturation > 1.0 ? 1.0 : s+saturation;

vec4 newPixel = vec4(h, s, l, 1.0);
vec3 rgbPixel =  hsv2rgb(vec3(h,s,l));
return premultiply(vec4(rgbPixel.r,rgbPixel.g,rgbPixel.b,1.0));
}
/*
vec4 hsl2rgb(sampler image)
{ vec4 pixel = sample(image, samplerCoord(image));
return hsv2rgb(pixel);
}*/
